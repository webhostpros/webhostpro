#!/usr/bin/env python3
import glob
import os
import re
import time
from html import unescape
from pathlib import Path

BACKUP_NAME = "index.webalizer.bak.html"
USAGE_RE = re.compile(r"usage_(\d{6})\.html$", re.IGNORECASE)


def is_webalizer_index(html: str) -> bool:
    return ("Generated by The Webalizer" in html) or ("Webalizer Version" in html)


def is_whp_index(html: str) -> bool:
    h = (html or "").lower()
    return ("traffic insights" in h) and ("top pages" in h or "monthly reports" in h)


def strip_tags(s: str) -> str:
    out = re.sub(r"<script\b.*?</script>", " ", s or "", flags=re.IGNORECASE | re.DOTALL)
    out = re.sub(r"<style\b.*?</style>", " ", out, flags=re.IGNORECASE | re.DOTALL)
    out = re.sub(r"<.*?>", " ", out, flags=re.DOTALL)
    out = unescape(out)
    return " ".join(out.split()).strip()


def yyyymm_to_label(yyyymm: str) -> str:
    if not yyyymm or len(yyyymm) != 6 or not yyyymm.isdigit():
        return "—"
    y, m = int(yyyymm[:4]), int(yyyymm[4:6])
    months = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
    return f"{months[m - 1]} {y}" if 1 <= m <= 12 else yyyymm


def write_file_atomic(path: Path, content: str, uid: int, gid: int, mode: int = 0o644):
    tmp = path.with_suffix(path.suffix + f".tmp.{os.getpid()}")
    tmp.write_text(content, encoding="utf-8")
    os.chown(tmp, uid, gid)
    os.chmod(tmp, mode)
    os.replace(tmp, path)


def find_usage_files(d: Path):
    return sorted(d.glob("usage_[0-9][0-9][0-9][0-9][0-9][0-9].html"))


def find_latest_usage_html(d: Path):
    files = find_usage_files(d)
    return files[-1] if files else None


def build_month_links_from_files(d: Path) -> str:
    files = sorted(find_usage_files(d), reverse=True)
    if not files:
        return "<p>No monthly reports found.</p>"
    items = []
    for f in files:
        m = USAGE_RE.search(f.name)
        yyyymm = m.group(1) if m else ""
        items.append(f'<li><a href="{f.name}">{yyyymm_to_label(yyyymm)}</a></li>')
    return "<ul>" + "\n".join(items) + "</ul>"


def parse_current_row_from_index(index_html: str):
    m = re.search(r'<A HREF="usage_(\d{6})\.html".*?</A></TD>(.*?)</TR>', index_html, re.IGNORECASE | re.DOTALL)
    if not m:
        return {}
    yyyymm, row = m.group(1), m.group(2)
    nums = re.findall(r'ALIGN=right><FONT SIZE="-1">([^<]+)</FONT>', row, re.IGNORECASE)
    if len(nums) < 10:
        return {"yyyymm": yyyymm}

    def to_int(s):
        t = s.strip().replace(",", "")
        return int(t) if t.isdigit() else None

    return {
        "yyyymm": yyyymm,
        "monthly_sites": to_int(nums[4]),
        "monthly_visits": to_int(nums[6]),
        "monthly_hits": to_int(nums[9]),
    }


def extract_domain_from_webalizer_source(html: str, fallback: str) -> str:
    m = re.search(r"<TITLE>\s*Usage Statistics for\s+(.+?)\s*-", html or "", re.IGNORECASE)
    if m:
        return strip_tags(m.group(1))
    pill = re.search(r'<span class="pill">(.*?)</span>', html or "", re.IGNORECASE | re.DOTALL)
    if pill:
        return strip_tags(pill.group(1))
    return fallback


def parse_tables(usage_html: str):
    tables = []
    for t_html in re.findall(r"<TABLE\b.*?</TABLE>", usage_html, re.IGNORECASE | re.DOTALL):
        rows = []
        for tr in re.findall(r"<TR\b.*?>.*?</TR>", t_html, re.IGNORECASE | re.DOTALL):
            headers = re.findall(r"<TH\b.*?>\s*(.*?)\s*</TH>", tr, re.IGNORECASE | re.DOTALL)
            cells = re.findall(r"<TD\b.*?>\s*(.*?)\s*</TD>", tr, re.IGNORECASE | re.DOTALL)
            hs = [strip_tags(c) for c in headers if strip_tags(c)]
            cs = [strip_tags(c) for c in cells if strip_tags(c)]
            if hs and len(hs) >= len(cs):
                rows.append(("h", hs))
            elif cs:
                rows.append(("d", cs))
        if rows:
            tables.append({"rows": rows, "text": strip_tags(t_html).lower()})
    return tables


def normalize_num(txt: str):
    t = (txt or "").strip().replace(",", "")
    return int(t) if t.isdigit() else None


def looks_like_referrer(s: str) -> bool:
    s = (s or "").strip()
    if not s:
        return False
    sl = s.lower()
    if sl in {"-", "none", "unknown"}:
        return False
    if any(sl.startswith(p) for p in ("total ", "hits per", "files per", "sites per", "visits per", "kbytes per", "code ")):
        return False
    if re.fullmatch(r"[\d\s.,%]+", s):
        return False
    if "%" in s:
        return False
    if sl.startswith(("http://", "https://")):
        return True
    return ("." in s and " " not in s)


def looks_like_page(s: str) -> bool:
    s = (s or "").strip().lower()
    if not s.startswith("/"):
        return False
    if any(s.startswith(p) for p in ("/awstats", "/webalizer")):
        return False
    path = s.split("?", 1)[0].split("#", 1)[0]
    if path.endswith("/"):
        return True

    tail = path.rsplit("/", 1)[-1]
    if "." not in tail:
        return True

    allowed = {"php", "html", "htm", "asp", "aspx", "jsp", "cfm", "cgi", "pl", "shtml"}
    blocked = {
        "js", "css", "png", "jpg", "jpeg", "gif", "svg", "webp", "ico", "bmp", "tif", "tiff",
        "woff", "woff2", "ttf", "eot", "otf", "map", "pdf", "zip", "gz", "rar", "7z", "xml", "json",
        "txt", "csv", "mp3", "mp4", "mov", "avi", "webm"
    }
    ext = tail.rsplit(".", 1)[-1]
    if ext in allowed:
        return True
    if ext in blocked:
        return False
    return False


def looks_like_day_label(s: str) -> bool:
    s = (s or "").strip().lower()
    if not s:
        return False
    if s.isdigit():
        n = int(s)
        return 1 <= n <= 31
    if re.match(r"^\d{4}-\d{2}-\d{2}$", s):
        return True
    if re.match(r"^(mon|tue|wed|thu|fri|sat|sun)\b", s):
        return True
    if re.match(r"^[a-z]{3,9}\s+\d{1,2}$", s):
        return True
    return False


def table_keyword_bonus(text: str, kind: str) -> int:
    t = text or ""
    if kind == "ref":
        return 5 if ("referrer" in t or "referrers" in t or "referer" in t) else 0
    if kind == "page":
        return 3 if ("top urls" in t or "top pages" in t or "urls" in t or "pages" in t) else 0
    if kind == "exit":
        return 8 if ("exit" in t and "page" in t) else (4 if "exit" in t else 0)
    if kind == "daily":
        return 8 if ("daily" in t and ("stats" in t or "totals" in t)) else (5 if "daily" in t else 0)
    return 0


def score_table(table, kind: str):
    rows = table["rows"]
    text = table["text"]
    data_rows = [r for typ, r in rows if typ == "d"]
    if len(data_rows) < 3:
        return [], -1

    max_cols = max(len(r) for r in data_rows)

    label_idx, label_score = None, -1
    for idx in range(min(max_cols, 10)):
        sc = 0
        for r in data_rows[:150]:
            if idx >= len(r):
                continue
            val = r[idx]
            if kind == "ref" and looks_like_referrer(val):
                sc += 1
            elif kind in {"page", "exit"} and looks_like_page(val):
                sc += 1
            elif kind == "daily" and looks_like_day_label(val):
                sc += 1
        if sc > label_score:
            label_idx, label_score = idx, sc

    min_score = 3 if kind != "daily" else 4
    if label_idx is None or label_score < min_score:
        return [], -1

    numeric_cols = []
    for idx in range(min(max_cols, 12)):
        if idx == label_idx:
            continue
        vals = [normalize_num(r[idx]) for r in data_rows if idx < len(r)]
        vals = [v for v in vals if isinstance(v, int)]
        if len(vals) >= 3:
            numeric_cols.append((idx, sum(vals) / len(vals), len(vals)))
    if not numeric_cols:
        return [], -1

    numeric_cols.sort(key=lambda x: x[1], reverse=True)
    hits_idx = numeric_cols[0][0]
    visits_idx = None
    sites_idx = None

    for idx, avg, _ in numeric_cols[1:]:
        if visits_idx is None and avg <= numeric_cols[0][1]:
            visits_idx = idx
            continue
        if visits_idx is not None and sites_idx is None and avg <= (next(v for i, v, _ in numeric_cols if i == visits_idx)):
            sites_idx = idx
            break

    out = []
    for r in data_rows:
        if label_idx >= len(r):
            continue
        label = r[label_idx]

        if kind == "ref" and not looks_like_referrer(label):
            continue
        if kind in {"page", "exit"} and not looks_like_page(label):
            continue
        if kind == "daily" and not looks_like_day_label(label):
            continue

        hits = normalize_num(r[hits_idx]) if hits_idx < len(r) else None
        visits = normalize_num(r[visits_idx]) if visits_idx is not None and visits_idx < len(r) else None
        sites = normalize_num(r[sites_idx]) if sites_idx is not None and sites_idx < len(r) else None

        out.append({"label": label, "hits": hits, "visits": visits, "sites": sites})

    if kind == "daily":
        def day_sort_key(x):
            lbl = x["label"].strip()
            if lbl.isdigit():
                return int(lbl)
            return 999
        out.sort(key=day_sort_key)
    else:
        out.sort(key=lambda x: (x["hits"] is None, -(x["hits"] or 0), x["label"]))

    quality = label_score + table_keyword_bonus(text, kind)
    return out, quality


def extract_sections(usage_html: str, limit: int = 25):
    best = {
        "ref": ([], -1),
        "page": ([], -1),
        "exit": ([], -1),
        "daily": ([], -1),
    }

    for table in parse_tables(usage_html or ""):
        for kind in ("ref", "page", "exit", "daily"):
            items, quality = score_table(table, kind)
            if quality > best[kind][1]:
                best[kind] = (items, quality)

    return {
        "referrers": best["ref"][0][:limit],
        "pages": best["page"][0][:limit],
        "exit_pages": best["exit"][0][:limit],
        "daily": best["daily"][0],
    }


def render_ranked_table(title: str, items):
    if not items:
        return f"""
        <div class="section">
          <h2>{title}</h2>
          <div class="empty">No data found in the latest monthly report.</div>
        </div>
        """

    rows = []
    for i in items:
        hits = f"{i['hits']:,}" if isinstance(i.get("hits"), int) else "—"
        visits = f"{i['visits']:,}" if isinstance(i.get("visits"), int) else "—"
        sites = f"{i['sites']:,}" if isinstance(i.get("sites"), int) else "—"
        rows.append(f"<tr><td>{i['label']}</td><td class='num'>{hits}</td><td class='num'>{visits}</td><td class='num'>{sites}</td></tr>")

    return f"""
    <div class="section">
      <h2>{title}</h2>
      <div class="tablewrap">
        <table class="t">
          <thead>
            <tr>
              <th>Name</th>
              <th class="num">Hits</th>
              <th class="num">Visits</th>
              <th class="num">Visitors (Sites)</th>
            </tr>
          </thead>
          <tbody>{''.join(rows)}</tbody>
        </table>
      </div>
    </div>
    """


def render_daily_table(items):
    if not items:
        return """
        <div class="section">
          <h2>Daily Stats</h2>
          <div class="empty">No daily data found in the latest monthly report.</div>
        </div>
        """

    rows = []
    for i in items:
        hits = f"{i['hits']:,}" if isinstance(i.get("hits"), int) else "—"
        visits = f"{i['visits']:,}" if isinstance(i.get("visits"), int) else "—"
        sites = f"{i['sites']:,}" if isinstance(i.get("sites"), int) else "—"
        rows.append(f"<tr><td>{i['label']}</td><td class='num'>{hits}</td><td class='num'>{visits}</td><td class='num'>{sites}</td></tr>")

    return f"""
    <div class="section">
      <h2>Daily Stats</h2>
      <div class="tablewrap">
        <table class="t">
          <thead>
            <tr>
              <th>Day</th>
              <th class="num">Hits</th>
              <th class="num">Visits</th>
              <th class="num">Visitors (Sites)</th>
            </tr>
          </thead>
          <tbody>{''.join(rows)}</tbody>
        </table>
      </div>
    </div>
    """


def build_modern_index(domain: str, generated: str, summary: dict, month_links_html: str, sections: dict):
    month_label = yyyymm_to_label(summary.get("yyyymm", ""))

    def fmt(n):
        return f"{n:,}" if isinstance(n, int) else "—"

    ref_block = render_ranked_table("Top Referrers (Top 25)", sections.get("referrers", []))
    pages_block = render_ranked_table("Top Pages (Top 25)", sections.get("pages", []))
    exits_block = render_ranked_table("Top Exit Pages (Top 25)", sections.get("exit_pages", []))
    daily_block = render_daily_table(sections.get("daily", []))

    return f"""<!doctype html>
<html lang=\"en\">
<head>
<meta charset=\"utf-8\">
<meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">
<title>Traffic Insights for {domain}</title>
<style>
:root {{ color-scheme: dark; --bg:#0b1220; --panel:#121a2b; --muted:#8ea0c2; --text:#e9f0ff; --teal:#006c6e; }}
body {{ margin:0; background:var(--bg); font:14px/1.5 system-ui,-apple-system,Segoe UI,Roboto,Arial; color:var(--text); }}
.wrap {{ max-width:1100px; margin:0 auto; padding:22px 18px 36px; }}
h1 {{ margin:0 0 6px; font-size:20px; font-weight:700; }}
.sub {{ color:var(--muted); margin:0 0 18px; }}
.grid {{ display:grid; grid-template-columns:repeat(3,minmax(0,1fr)); gap:12px; margin:16px 0 18px; }}
.card {{ background:var(--panel); border-radius:16px; padding:14px; }}
.k {{ color:var(--muted); font-size:12px; margin:0 0 6px; }}
.v {{ font-size:22px; font-weight:750; margin:0; }}
.pill {{ display:inline-block; background:rgba(0,108,110,.22); color:#b9ffff; padding:4px 10px; border-radius:999px; font-size:12px; }}
.section {{ background:var(--panel); border-radius:18px; padding:14px; margin-top:12px; }}
.section h2 {{ margin:0 0 10px; font-size:14px; color:#dfe8ff; }}
.empty {{ color:var(--muted); font-size:12px; padding:6px 0 2px; }}
.months ul {{ margin:0; padding-left:18px; columns:3; gap:24px; }}
.months a {{ color:#cfe3ff; text-decoration:none; }}
.months a:hover {{ text-decoration:underline; }}
.t {{ width:100%; border-collapse:collapse; }}
.t th,.t td {{ padding:10px 8px; border-bottom:1px solid rgba(255,255,255,.06); vertical-align:top; }}
.t th {{ text-align:left; font-size:12px; color:#dfe8ff; }}
.num, .t th.num {{ text-align:right; white-space:nowrap; }}
.tablewrap {{ overflow:auto; }}
@media (max-width:860px) {{ .grid {{ grid-template-columns:1fr; }} .months ul {{ columns:1; }} }}
</style>
</head>
<body>
  <div class=\"wrap\">
    <h1>Traffic Insights <span class=\"pill\">{domain}</span></h1>
    <p class=\"sub\">Timeframe: <strong>{month_label}</strong> (monthly totals). Generated {generated}.</p>
    <div class=\"grid\">
      <div class=\"card\"><p class=\"k\">Visitors (Sites)</p><p class=\"v\">{fmt(summary.get('monthly_sites'))}</p></div>
      <div class=\"card\"><p class=\"k\">Hits</p><p class=\"v\">{fmt(summary.get('monthly_hits'))}</p></div>
      <div class=\"card\"><p class=\"k\">Visits</p><p class=\"v\">{fmt(summary.get('monthly_visits'))}</p></div>
    </div>
    {ref_block}
    {pages_block}
    {exits_block}
    {daily_block}
    <div class=\"section months\">
      <h2>Monthly Reports</h2>
      {month_links_html}
    </div>
  </div>
</body>
</html>
"""


def process_dir(d: Path):
    latest = find_latest_usage_html(d)
    if not latest or not latest.exists():
        return False

    index_path = d / "index.html"
    backup_path = d / BACKUP_NAME

    if index_path.exists():
        st = index_path.stat()
        uid, gid, mode = st.st_uid, st.st_gid, st.st_mode & 0o777
        current_html = index_path.read_text(errors="ignore")
    else:
        st = d.stat()
        uid, gid, mode = st.st_uid, st.st_gid, 0o644
        current_html = ""

    if is_webalizer_index(current_html) and not backup_path.exists():
        write_file_atomic(backup_path, current_html, uid, gid, 0o644)

    if backup_path.exists():
        source_html = backup_path.read_text(errors="ignore")
    elif is_webalizer_index(current_html) or is_whp_index(current_html):
        source_html = current_html
    else:
        source_html = ""

    domain = extract_domain_from_webalizer_source(source_html, fallback=d.name)
    summary = parse_current_row_from_index(source_html) or {}

    m = USAGE_RE.search(latest.name)
    if m:
        summary["yyyymm"] = m.group(1)

    month_links = build_month_links_from_files(d)
    generated = time.strftime("%Y-%m-%d %H:%M:%S %Z")
    usage_html = latest.read_text(errors="ignore")
    sections = extract_sections(usage_html, limit=25)

    modern = build_modern_index(
        domain=domain,
        generated=generated,
        summary=summary,
        month_links_html=month_links,
        sections=sections,
    )

    write_file_atomic(index_path, modern, uid, gid, mode)
    return True


def debug_extract_for_folder(folder: str):
    """Quick sanity helper: pass a webalizer folder path, get extraction preview dict."""
    d = Path(folder)
    latest = find_latest_usage_html(d)
    if not latest:
        return {"folder": str(d), "error": "No usage_YYYYMM.html found"}
    html = latest.read_text(errors="ignore")
    sections = extract_sections(html, limit=10)
    return {
        "folder": str(d),
        "latest": latest.name,
        **sections,
    }


def iter_webalizer_dirs():
    patterns = [
        "/home/*/tmp/webalizer/index.html",
        "/home/*/tmp/webalizer/*/index.html",
        "/home/*/tmp/webalizer/ssl/*/index.html",
    ]
    seen = set()
    for pat in patterns:
        for idx in glob.glob(pat):
            if idx.startswith("/home/virtfs/"):
                continue
            d = str(Path(idx).parent)
            if d not in seen:
                seen.add(d)
                yield Path(d)

    for usage in glob.glob("/home/*/tmp/webalizer/**/usage_[0-9][0-9][0-9][0-9][0-9][0-9].html", recursive=True):
        if usage.startswith("/home/virtfs/"):
            continue
        d = str(Path(usage).parent)
        if d not in seen:
            seen.add(d)
            yield Path(d)


def main():
    changed = 0
    for d in iter_webalizer_dirs():
        try:
            if process_dir(d):
                changed += 1
        except Exception:
            continue
    print(f"whp-webalizer-ui-render: updated {changed} webalizer index pages")


if __name__ == "__main__":
    main()
